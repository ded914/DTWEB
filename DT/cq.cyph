MATCH (f:Frame{name: 'Complaints' })-[hs:HAS_SLOT]->(s:Slot)
OPTIONAL MATCH (s)-[ht:HAS_TERM]->(t:Term)
WITH f,s,hs,ht, t
ORDER BY ht.index
WITH f,s,hs,
CASE WHEN t IS NOT NULL THEN collect({nodetype: 'term', title: t.name, index: ht.index}) ELSE [] END as c_terms
ORDER BY hs.index
WITH collect({title: s.name, nodetype: 'slot', index:hs.index,  nodes: c_terms}) as c_slotrows
MATCH (f:Frame{name: 'Complaints' })-[ltf:LINK_TO_FRAME]->(sf:Frame)
WITH ltf, f, c_slotrows + collect({title: sf.name, nodetype: 'framelink', index: ltf.index}) as c_allrows
WITH f, c_allrows
UNWIND c_allrows AS u_allrows
WITH f, u_allrows
ORDER BY u_allrows.index
WITH {title:f.name, nodes:collect(u_allrows)} AS frame
RETURN frame.nodes


